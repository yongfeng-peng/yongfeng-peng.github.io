<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="(女英">
<meta property="og:type" content="website">
<meta property="og:title" content="Shero.">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Shero.">
<meta property="og:description" content="(女英">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shero.">
<meta name="twitter:description" content="(女英">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Shero.</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas>
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
  <script type="text/javascript" src="/js/src/fireworks.js"></script>
  

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shero.</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活百般滋味，你要笑着面对😊</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/28/react钩子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/28/react钩子/" itemprop="url">react钩子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-28T15:23:21+08:00">
                2020-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="react钩子（hooks）"><a href="#react钩子（hooks）" class="headerlink" title="react钩子（hooks）"></a>react钩子（hooks）</h3><h4 id="react组件"><a href="#react组件" class="headerlink" title="react组件"></a>react组件</h4><ul>
<li>React 的核心是组件。v16.8 版本之前，组件的标准写法是类（class）</li>
<li>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</li>
<li>任何一个组件都可以用类和钩子来写</li>
<li><p>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大部分看到上面两段代码都会选择使用钩子，更简洁、代码量少、用起来也较轻，也更符合react<em>函数式都本质</em></p>
<ul>
<li>类有很多强制性的语法约束、不易混乱，更适合初学者</li>
<li>真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂</li>
</ul>
</li>
<li>而类就比较重，官方也推荐使用钩子（函数），而不是类<ul>
<li>钩子的灵活性比较大</li>
<li>react 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类</li>
</ul>
</li>
</ul>
<h4 id="类、函数的差异"><a href="#类、函数的差异" class="headerlink" title="类、函数的差异"></a>类、函数的差异</h4><ul>
<li>毕竟写法不同，还是存在不同的编程方法论</li>
<li>类是<strong>数据和逻辑的封装</strong>，即组件的状态和操作方法是封装在一起的</li>
<li>函数一般来说，只应该做一件事，就是返回一个值，如：react 的函数组件只应该做一件事情=》返回组件的 HTML 代码，而没有其他的功能</li>
<li>这种只进行单纯的数据计算（换算）的函数，在函数式编程里面称为 “纯函数”（pure function）</li>
</ul>
<h4 id="副效应"><a href="#副效应" class="headerlink" title="副效应"></a>副效应</h4><ul>
<li>函数式编程将那些跟数据计算无关的操作，都称为 “副效应” （side effect） ，</li>
<li>如果函数内部直接包含产生副效应的操作，就不再是纯函数了，我们称之为不纯的函数，如（生成日志、储存数据、改变应用状态等等）</li>
<li>纯函数内部只有通过间接的手段（即通过其他函数调用），才能包含副效应，如（钩子）</li>
</ul>
<h4 id="钩子（hook）"><a href="#钩子（hook）" class="headerlink" title="钩子（hook）"></a>钩子（hook）</h4><ul>
<li><strong>react函数组件的副效应解决方案，用来为函数组件引入副效应</strong>. 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入</li>
<li><p>React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<ul>
<li>useState()：保存状态</li>
<li><p>useContext()：保存上下文（共享状态钩子）</p>
<ul>
<li>组件之间共享状态，可以使用useContext()</li>
<li><p>使用 React Context API，在组件外部建立一个 Context</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const AppContext = React.createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享</p>
</li>
<li>useContext()钩子函数用来引入 Context 对象，从中获取username属性</li>
</ul>
</li>
<li>useRef()：保存引用</li>
<li><p>useReducer()：action 钩子</p>
<ul>
<li>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux</li>
<li>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState</li>
<li><p>useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个值是状态的当前值，第二个值是发送 action 的dispatch函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useContext &#125; from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">const myReducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch(action.type)  &#123;</span><br><span class="line">    case(&apos;countUp&apos;):</span><br><span class="line">      return  &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    default:</span><br><span class="line">      return  state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(myReducer, &#123; count:   0 &#125;);</span><br><span class="line">  return  (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &apos;countUp&apos; &#125;)&#125;&gt;</span><br><span class="line">        +1</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux</p>
</li>
</ul>
</li>
<li>以上钩子都是引入某种特定的副效应，而 useEffect()是通用的副效应钩</li>
<li><a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener">……</a></li>
</ul>
</li>
</ul>
<h4 id="useEffect-的用法"><a href="#useEffect-的用法" class="headerlink" title="useEffect() 的用法"></a>useEffect() 的用法</h4><ul>
<li>useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合</li>
<li>useEffect()本身是一个函数，由 React 框架提供，在函数组件内部调用即可</li>
<li><p>useEffect()的作用就是指定一个副效应函数，组件每渲染一次，该函数就自动执行一次。组件首次在网页 DOM 加载后，副效应函数也会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function Welcome(props) &#123;</span><br><span class="line">  let [count, setCount] = useState(1); // 数组解构</span><br><span class="line">  // 以上代码等价于</span><br><span class="line">  // let countStateVariable = React.useState(1); // 返回一个有两个元素的数组</span><br><span class="line">  // let count = countStateVariable[0]; // 数组里的第一个值 当前的state</span><br><span class="line">  // let setCount = countStateVariable[1]; // 数组里的第二个值 更新state的函数</span><br><span class="line">  // 使用 [0] 和 [1] 来访问有点令人困惑，因为它们有特定的含义。这就是我们使用数组解构的原因。</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `you click $&#123;count&#125; times`;</span><br><span class="line">  &#125;,)</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;hello, &#123; props.title &#125;,&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;累加&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useEffect() 的第二个参数,不希望useEffect()每次渲染都执行，这时可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会重新渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `Hello, $&#123;props.name&#125;`;</span><br><span class="line">  &#125;, [props.name]);</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="useEffect-的用途"><a href="#useEffect-的用途" class="headerlink" title="useEffect() 的用途"></a>useEffect() 的用途</h3><ul>
<li>只要是副效应，都可以使用useEffect()引入。它的常见用途有下面几种。<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
</li>
</ul>
<h4 id="useEffect-的返回值"><a href="#useEffect-的返回值" class="headerlink" title="useEffect() 的返回值"></a>useEffect() 的返回值</h4><ul>
<li>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应</li>
<li>useEffect()允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，useEffect()就不用返回任何值</li>
<li>useEffect()在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const subscription = props.source.subscribe();</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.source]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="useEffect-的注意点"><a href="#useEffect-的注意点" class="headerlink" title="useEffect() 的注意点"></a>useEffect() 的注意点</h4><ul>
<li><a href="https://react.docschina.org/docs/hooks-rules.html" target="_blank" rel="noopener">了解Hook规则</a></li>
<li>使用useEffect()时，有一点需要注意。如果有多个副效应，应该调用多个useEffect()，而不应该合并写在一起<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [varA, setVarA] = useState(0);</span><br><span class="line">  const [varB, setVarB] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const timeout = setTimeout(() =&gt; setVarA(varA + 1), 1000);</span><br><span class="line">    return () =&gt; clearTimeout(timeout);</span><br><span class="line">  &#125;, [varA]);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    const timeout = setTimeout(() =&gt; setVarB(varB + 2), 2000);</span><br><span class="line"></span><br><span class="line">    return () =&gt; clearTimeout(timeout);</span><br><span class="line">  &#125;, [varB]);</span><br><span class="line"></span><br><span class="line">  return &lt;span&gt;&#123;varA&#125;, &#123;varB&#125;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="learn-more…"><a href="#learn-more…" class="headerlink" title="learn more…"></a><a href="http://www.ruanyifeng.com/blog/2020/09/react-hooks-useeffect-tutorial.html" target="_blank" rel="noopener">learn more…</a></h4><h4 id="learn-more…-1"><a href="#learn-more…-1" class="headerlink" title="learn more…"></a><a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html" target="_blank" rel="noopener">learn more…</a></h4><h3 id="code"><a href="#code" class="headerlink" title="code"></a><a href="https://github.com/yongfeng-peng/react-simple-sCode" target="_blank" rel="noopener">code</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/23/react原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/23/react原理/" itemprop="url">react原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-23T14:25:09+08:00">
                2020-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="react原理剖析"><a href="#react原理剖析" class="headerlink" title="react原理剖析"></a>react原理剖析</h3><h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a><a href="https://github.com/facebook/react/blob/master/packages/react/src/React.js" target="_blank" rel="noopener">核心API</a></h4><ul>
<li>React.createElement：创建虚拟的DOM</li>
<li>React.Component: 实现自定义组件</li>
<li>ReactDOM.render: 渲染真实DOM</li>
</ul>
<ul>
<li><a href="https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOM.js" target="_blank" rel="noopener">react-dom</a>：主要是render逻辑</li>
</ul>
<h4 id="JSX是什么"><a href="#JSX是什么" class="headerlink" title="JSX是什么"></a>JSX是什么</h4><ul>
<li><a href="https://reactjs.org/" target="_blank" rel="noopener">在线JSX预编译</a></li>
<li>react使用JSX来替代常规的JavaScript，JSX是一个看起来很像XML的JavaScript语法扩展<h4 id="为什么需要JXS"><a href="#为什么需要JXS" class="headerlink" title="为什么需要JXS"></a>为什么需要JXS</h4></li>
<li>JSX执行更快，因为它在编译为JavaScript代码后进行了优化（在react里面可以用它描述视图）</li>
<li>它是<strong>类型安全</strong>的，在编译过程中就能发现错误（编译器可以对它进行规范处理、一系列严谨转换、类型检测）</li>
<li>使用JSX编写模版更加简单快捷（开发效率）<h4 id="JXS怎么用"><a href="#JXS怎么用" class="headerlink" title="JXS怎么用"></a>JXS怎么用</h4></li>
<li>原理：babel-loader会预编译JSX为React.createElement(…)</li>
</ul>
<h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><ul>
<li>class组件的特点，就是拥有特殊状态并且可以通过setState更新状态，从而重新渲染视图，是学习React中最重要的api</li>
<li>setState并没有直接操作去渲染，而是执行了一个异步的updater队列,使用一个类来专门管理</li>
</ul>
<h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4><ul>
<li>用JavaScript对象表示DOM信息和结构，当状态变更的时候，重新渲染这个JavaScript的对象结构。这个JavaScript对象称为virtual dom</li>
<li>简单的说虚拟dom就是js对象，可以描述dom<br><img src="https://raw.githubusercontent.com/yongfeng-peng/yongfeng-peng.github.io/dev/source/images/vdom.jpg" alt="Image text"><!-- * ![Image text](/../images/vdom.jpg) -->
</li>
</ul>
<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><ul>
<li>diff策略<ul>
<li>同级比较，Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。例如：div-&gt;p, CompA-&gt;CompB</li>
<li>对于同一层级的一组子节点，通过唯一的key进行区分</li>
</ul>
</li>
<li>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明，这三个前提策略是合理且准确的，它保证了整体界面构建的性能</li>
<li>element diff 差异类型：<ul>
<li>替换原来的节点，例如把div换成了p，Comp1换成Comp2</li>
<li>移动、删除、新增子节点， 例如ul中的多个子节点li中出现了顺序互换</li>
<li>修改了节点的属性，例如节点类名发生了变化</li>
<li>对于文本节点，文本内容可能会改变</li>
</ul>
</li>
<li>重排（reorder）操作：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）<ul>
<li>INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作</li>
<li>MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的   DOM 节点</li>
<li>REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作</li>
</ul>
</li>
<li>为什么需要虚拟dom和对diff算法理解<ul>
<li>抽象出虚拟dom层，减少重布局、重排、重绘次数，不直接更新真实dom</li>
<li>比较出应不应该更新dom，即使更新，尽可能的一次性、批量的更新</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/react生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/22/react生命周期/" itemprop="url">react生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-22T09:52:44+08:00">
                2020-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="react生命周期-图谱"><a href="#react生命周期-图谱" class="headerlink" title="react生命周期 图谱"></a>react生命周期 <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图谱</a></h3><h4 id="react-v16-0前的生命周期"><a href="#react-v16-0前的生命周期" class="headerlink" title="react v16.0前的生命周期"></a>react v16.0前的生命周期</h4><ul>
<li>大部分团队不见得会跟进升到16版本，所以16前的生命周期还是很有必要掌握的，何况16也是基于之前的修改</li>
<li><p>第一组件初始化(initialization)阶段</p>
<ul>
<li>类的构造方法( constructor() ),Test类继承了react Component这个基类，即继承这个<strong>react的基类</strong>，才能有render(),生命周期等方法可以使用， 也是函数组件不能使用这些方法的原因。</li>
<li>super(props) 用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件，供子组件读取(组件中props只读不可变，state可变)。 而 constructor() 用来做一些组件的初始化工作，如定义this.state的初始内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class Test extends Component &#123; </span><br><span class="line">  constructor(props) &#123; </span><br><span class="line">    super(props); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第二组件的挂载(Mounting)阶段</p>
<ul>
<li>此阶段分为componentWillMount，render，componentDidMount三个时期</li>
<li>componentWillMount<ul>
<li>在组件挂载到DOM前调用，且只会被调用一次，在这边调用<strong>this.setState不会引起组件重新渲染</strong>，可把这里的内容提前到constructor()中，所以项目中很少用</li>
</ul>
</li>
<li>render<ul>
<li>根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面<br>DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用</li>
</ul>
</li>
<li>componentDidMount<ul>
<li>组件挂载到DOM后调用，且只会被调用一次</li>
</ul>
</li>
</ul>
</li>
<li><p>第三组件的更新(update)阶段</p>
<ul>
<li>此阶段分为componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate</li>
<li>componentWillReceiveProps(nextProps)<ul>
<li>只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render</li>
</ul>
</li>
<li>shouldComponentUpdate(nextProps, nextState)<ul>
<li>通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能</li>
<li>ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了</li>
</ul>
</li>
<li>componentWillUpdate(nextProps, nextState)<ul>
<li>在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用</li>
</ul>
</li>
<li>render<ul>
<li>render方法在上文讲过，这边只是重新调用</li>
</ul>
</li>
<li>componentDidUpdate(prevProps, prevState)<ul>
<li>在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state</li>
</ul>
</li>
<li><p>了解此阶段前需要先明确下react组件更新机制。setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。详细可看<a href="https://www.cnblogs.com/penghuwan/p/6707254.html&#39;" target="_blank" rel="noopener">这篇文章</a>造成组件更新有两类（三种）情况：<br>1.父组件重新render（父组件重新render引起子组件重新render的情况有两种）<br>a. 直接使用,每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123; </span><br><span class="line">  shouldComponentUpdate(nextProps)&#123; // 应该使用这个方法，否则无论props是否有变化都将会导致组件 跟着重新渲染</span><br><span class="line">    if(nextProps.someThings === this.props.someThings) &#123; </span><br><span class="line">      return false;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; </span><br><span class="line">    return &lt;div&gt;&#123;this.props.someThings&#125;&lt;/div&gt; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b.在componentWillReceiveProps方法中，将props转换成自己的state</p>
<ul>
<li>函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染</li>
<li>componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123; </span><br><span class="line">  constructor(props) &#123; </span><br><span class="line">    super(props); </span><br><span class="line">    this.state = &#123; </span><br><span class="line">      someThings: props.someThings </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123; // 父组件重传props时就会调用这个方法 </span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      someThings: nextProps.someThings</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; </span><br><span class="line">    return &lt;div&gt;&#123;this.state.someThings&#125;&lt;/div&gt; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123; </span><br><span class="line">  constructor(props) &#123; </span><br><span class="line">    super(props); </span><br><span class="line">    this.state = &#123; </span><br><span class="line">      someThings:1 </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  shouldComponentUpdate(nextStates) &#123; // 应该使用这个方法，否则无论state是否有变化都将会导致组 件重新渲染</span><br><span class="line">    if(nextStates.someThings === this.state.someThings) &#123; </span><br><span class="line">      return false;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = () =&gt; &#123; // 虽然调用了setState ，但state并无变化 </span><br><span class="line">    const preSomeThings = this.state.someThings;</span><br><span class="line">    this.setState(&#123; </span><br><span class="line">      someThings: preSomeThings </span><br><span class="line">    &#125;) </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; </span><br><span class="line">    return &lt;div onClick = &#123;this.handleClick&#125;&gt;&#123;this.state.someThings&#125;&lt;/div&gt; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第四卸载阶段</p>
<ul>
<li>只有一个生命周期方法：componentWillUnmount</li>
<li>componentWillUnmount<ul>
<li>在组件被卸载前调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器，清除componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="react-v16-4-的生命周期"><a href="#react-v16-4-的生命周期" class="headerlink" title="react v16.4 的生命周期"></a>react v16.4 的生命周期</h4><ul>
<li>变更缘由<ul>
<li>原来（React v16.0前）的生命周期在React v16推出的<a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener">Fiber</a>之后就不合适了，因为如果要开启async rendering， 在render函数之前的所有函数，都有可能被执行多次</li>
</ul>
</li>
<li>原来（React v16.0前）的生命周期有哪些是在render前执行的呢？<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
</ul>
</li>
<li>如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。禁止不能用比劝导开发者不要这样用的效果更好，所以除了shouldComponentUpdate，其他在render函数之前的所有函数(componentWillMount，componentWillReceiveProps，componentWillUpdate)都被getDerivedStateFromProps替代。也就是用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的stateReact v16.0刚推出的时候，是增加了一个componentDidCatch生命周期函数，这只是一个增量式修改，完全不影响原有生命周期函数；但是，到了React v16.3，大改动来了，引入了两个新的生命周期函数</li>
<li>新引入了两个新的生命周期函数： getDerivedStateFromProps ， getSnapshotBeforeUpdate<ul>
<li>getDerivedStateFromProps<ul>
<li>getDerivedStateFromProps 本来（React v16.3中）是只在创建和更新（由父组件引发部分），也就是不是不由父组件引发，那么getDerivedStateFromProps也不会被调用，如自身setState引发或者forceUpdate引发</li>
</ul>
</li>
</ul>
</li>
<li>React v16.3 这样的话理解起来有点乱，在React v16.4中改正了这一点，让getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用，具体可看React v16.4 的生命周期图</li>
<li>React v16.4后的getDerivedStateFromProps<ul>
<li>static getDerivedStateFromProps(props, state) 在组件创建时和更新时的render方法之前调用，它应该返回一个对象来更新状态，或者返回null来不更新任何内容</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate<ul>
<li>getSnapshotBeforeUpdate() 被调用于render之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123; </span><br><span class="line">  constructor(props) &#123; </span><br><span class="line">    super(props); </span><br><span class="line">    this.listRef = React.createRef(); </span><br><span class="line">  &#125;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123; //我们是否要添加新的 items 到列表? // 捕捉滚动位置，以便我们可以稍后调整滚动</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123; </span><br><span class="line">      const list = this.listRef.current; </span><br><span class="line">      return list.scrollHeight - list.scrollTop; </span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123; </span><br><span class="line">    //如果我们有snapshot值, 我们已经添加了 新的items </span><br><span class="line">    // 调整滚动以至于这些新的items 不会将旧items推出视图</span><br><span class="line">    // (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值) </span><br><span class="line">    if (snapshot !== null) &#123; </span><br><span class="line">      const list = this.listRef.current; </span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123; </span><br><span class="line">    return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/21/react组件化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/21/react组件化/" itemprop="url">react组件化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-21T10:46:03+08:00">
                2020-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="react组件化"><a href="#react组件化" class="headerlink" title="react组件化"></a>react组件化</h3><h4 id="使用antd的yarn-create-react-app-antd-demo创建的项目，使用组件配置按需加载"><a href="#使用antd的yarn-create-react-app-antd-demo创建的项目，使用组件配置按需加载" class="headerlink" title="使用antd的yarn create react-app antd-demo创建的项目，使用组件配置按需加载"></a>使用antd的yarn create react-app antd-demo创建的项目，使用组件配置按需加载</h4><ul>
<li>安装react-app-rewired取代react-scripts(package.json)，可以扩展webpack的配置 ，类似vue.config.js</li>
<li><p>项目根目录创建 config-overrides.js，配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const &#123; injectBabelPlugin &#125; = require(&quot;react-app-rewired&quot;);</span><br><span class="line">module.exports = function override(config, env) &#123;</span><br><span class="line">  config = injectBabelPlugin(</span><br><span class="line">    // 在默认配置基础上注入</span><br><span class="line">    // 插件名，插件配置</span><br><span class="line">    [&quot;import&quot;, &#123; libraryName: &quot;antd&quot;, libraryDirectory: &quot;es&quot;, style: &quot;css&quot; &#125;],</span><br><span class="line">    config</span><br><span class="line">  );</span><br><span class="line">  // 高级组件、可使用装饰器配置 ES7 -&gt; ES5</span><br><span class="line">  config = injectBabelPlugin(</span><br><span class="line">    [&quot;@babel/plugin-proposal-decorators&quot;, &#123; legacy: true &#125;],</span><br><span class="line">    config</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Button实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line">// antd.css都加载</span><br><span class="line">// import Button from &apos;antd/lib/button&apos;</span><br><span class="line">// import &apos;antd/dist/antd.css&apos;</span><br><span class="line">// 按需加载</span><br><span class="line">import &#123;Button&#125; from &apos;antd&apos;</span><br><span class="line"></span><br><span class="line">export default class AntdTest extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Button type=&quot;primary&quot;&gt;按钮&lt;/Button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="容器组件、函数组件，react渲染数据的深浅比较"><a href="#容器组件、函数组件，react渲染数据的深浅比较" class="headerlink" title="容器组件、函数组件，react渲染数据的深浅比较"></a>容器组件、函数组件，react渲染数据的深浅比较</h4><ul>
<li>容器组件负责数据获取，展示组件负责根据props显示信息</li>
<li>shouldComponentUpdate</li>
<li><p>PureComponent (定制了shouldComponentUpdate后的Component（浅比较）)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Comp extends React.PureComponent &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>memo高阶组件(React v16.6.0 之后的版本，可以使用 React.memo 让函数式的组件也有PureComponent的功能)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Demo = React.memo(() =&gt; ( &lt;div&gt;&#123;this.props.value || &apos;loading...&apos; &#125; &lt;/div&gt; ));</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; func &#125; from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">// 容器组件</span><br><span class="line">export default class CommentList extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // 不断轮询比较、耗费🆓</span><br><span class="line">    // setInterval(() =&gt; &#123; // 每次生成的是全新数组</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        comments: [</span><br><span class="line">          &#123; body: &quot;react is very good&quot;, author: &quot;facebook&quot; &#125;,</span><br><span class="line">          &#123; body: &quot;vue is very good&quot;, author: &quot;youyuxi&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.comments.map((c, i) =&gt; (</span><br><span class="line">          &lt;Comment key=&#123;i&#125; data=&#123;c&#125; /&gt;</span><br><span class="line">          // &lt;Comment key=&#123;i&#125; body=&#123;c.body&#125; author=&#123;c.author&#125; /&gt;</span><br><span class="line">          // &lt;Comment key=&#123;i&#125; &#123;...c&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 展示组件</span><br><span class="line">// memo高阶组件（也是一个函数，接收一个组件、返回一个全新的组件）,也是浅比较（实现原理和使用PureComponent一样，解决了以前函数组件不能使用PureComponent）</span><br><span class="line">// React v16.6.0 之后的版本，可以使用 React.memo 让函数式的组件也有PureComponent的功能</span><br><span class="line">// const Comment = React.memo(function(props) &#123;</span><br><span class="line">//   console.log(&quot;render Comment&quot;); // 执行两次</span><br><span class="line">//   return (</span><br><span class="line">//     &lt;div&gt;</span><br><span class="line">//       &lt;p&gt;&#123;props.body&#125;&lt;/p&gt;</span><br><span class="line">//       &lt;p&gt; --- &#123;props.author&#125;&lt;/p&gt;</span><br><span class="line">//     &lt;/div&gt;</span><br><span class="line">//   );</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// 使用PureComponent （15.3 版本） 浅比较，避免对象比较（引用类型），挖掘太深，也没有达到效果</span><br><span class="line">// 解决 数据没有变 render函数不执行</span><br><span class="line">// 传值类型、或者避免引用类型的地址不变（尽量一层）</span><br><span class="line">// class Comment extends React.PureComponent&#123;</span><br><span class="line">//   render() &#123;</span><br><span class="line">//     console.log(&quot;render comment&quot;);</span><br><span class="line">//     return (</span><br><span class="line">//       &lt;div&gt;</span><br><span class="line">//         &lt;p&gt;&#123;this.props.body&#125;&lt;/p&gt;</span><br><span class="line">//         &lt;p&gt; --- &#123;this.props.author&#125;&lt;/p&gt;</span><br><span class="line">//       &lt;/div&gt;</span><br><span class="line">//     );</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// class Comment extends React.Component&#123;</span><br><span class="line">//   // 生命周期进行比较 新状态nextProps 与 data比较</span><br><span class="line">//   // 弊端： 比较累赘</span><br><span class="line">//   shouldComponentUpdate(nextProps)&#123;</span><br><span class="line">//       if (nextProps.data.body === this.props.data.body &amp;&amp;</span><br><span class="line">//         nextProps.data.author === this.props.data.author) &#123;</span><br><span class="line">//           return false;</span><br><span class="line">//       &#125;</span><br><span class="line">//       return true;</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   render() &#123;</span><br><span class="line">//     console.log(&quot;render comment&quot;); // 执行了2次</span><br><span class="line">//     return (</span><br><span class="line">//       &lt;div&gt;</span><br><span class="line">//         &lt;p&gt;&#123;this.props.data.body&#125;&lt;/p&gt;</span><br><span class="line">//         &lt;p&gt; --- &#123;this.props.data.author&#125;&lt;/p&gt;</span><br><span class="line">//       &lt;/div&gt;</span><br><span class="line">//     );</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">function Comment(&#123;data&#125;)&#123;</span><br><span class="line">  console.log(&quot;render comment&quot;); // 执行了4次</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;data.body&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt; --- &#123;data.author&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><ul>
<li>在React里就有了HOC（Higher-Order Components）的概念</li>
<li>高阶组件也是一个组件，但是他返回另外一个组件，产生新的组件可以对属性进行包装，甚至重写部分生命周期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const demoComp = (Component) =&gt; &#123; </span><br><span class="line">  const NewComponent = (props) =&gt; &#123; </span><br><span class="line">    return &lt;Component &#123;...props&#125; name=&apos;demo组件&apos; /&gt;; </span><br><span class="line">  &#125;;</span><br><span class="line">    return NewComponent; </span><br><span class="line">  &#125;;</span><br><span class="line">// 上面demoComp组件，其实就是代理了Component，只是多传递了一个name参数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="高阶链式调用"><a href="#高阶链式调用" class="headerlink" title="高阶链式调用"></a>高阶链式调用</h4><ul>
<li>高阶组件最巧妙的一点，是可以链式调用</li>
</ul>
<h4 id="高阶组件装饰器写法"><a href="#高阶组件装饰器写法" class="headerlink" title="高阶组件装饰器写法"></a>高阶组件装饰器写法</h4><ul>
<li>ES7装饰器可用于简化高阶组件写法</li>
<li>npm install –save-dev babel-plugin-transform-decorators-legacy</li>
<li>同上，项目根目录创建 config-overrides.js，配置</li>
<li>参考源码 <a href="https://github.com/yongfeng-peng/my-react-demo/blob/master/src/components/Hoc.js" target="_blank" rel="noopener">https://github.com/yongfeng-peng/my-react-demo/blob/master/src/components/Hoc.js</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 高级组件、可使用装饰器配置 ES7 -&gt; ES5</span><br><span class="line">config = injectBabelPlugin(</span><br><span class="line">  [&quot;@babel/plugin-proposal-decorators&quot;, &#123; legacy: true &#125;],</span><br><span class="line">  config</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="组件跨层级通信-上下文"><a href="#组件跨层级通信-上下文" class="headerlink" title="组件跨层级通信 - 上下文"></a>组件跨层级通信 - 上下文</h4><ul>
<li>组件跨层级通信可使用Context</li>
<li>这种模式下有两个角色，Provider和Consumer</li>
<li>Provider为外层组件，用来提供 数据；内部需要数据时用Consumer来读取<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const FormContext = React.createContext()</span><br><span class="line">const FormProvider = FormContext.Provider</span><br><span class="line">const FormConsumer = FormContext.Consumer</span><br><span class="line">let store = &#123; </span><br><span class="line">  name: &apos;学习&apos;, </span><br><span class="line">  sayHi() &#123; </span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let withForm = Component=&gt; &#123; </span><br><span class="line">  const NewComponent = (props) =&gt; &#123; </span><br><span class="line">    return &lt;FormProvider value=&#123;store&#125;&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/FormProvider&gt; </span><br><span class="line">  &#125;;</span><br><span class="line">  return NewComponent; </span><br><span class="line">&#125;</span><br><span class="line">@withForm class App extends Component &#123; </span><br><span class="line">  render() &#123; </span><br><span class="line">    return &lt;FormConsumer&gt; &#123; </span><br><span class="line">      store=&gt; &#123; </span><br><span class="line">        return &lt;Button onClick=&#123;()=&gt;store.sayHi()&#125;&gt; &#123;store.name&#125; &lt;/Button&gt; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; &lt;/FormConsumer&gt; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a><a href="https://github.com/yongfeng-peng/my-react-demo" target="_blank" rel="noopener">code</a></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/19/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/19/react/" itemprop="url">react</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-19T10:56:17+08:00">
                2020-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><h4 id="React和ReactDOM"><a href="#React和ReactDOM" class="headerlink" title="React和ReactDOM"></a>React和ReactDOM</h4><ul>
<li>React逻辑控制(义务控制、视图模型控制)，React.createElement()（生成虚拟DOM，React生成的组件或者数据与render渲染的数据进行diff,打补丁）</li>
</ul>
<h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><ul>
<li><p>表达式: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;expr&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&#123;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>jsx也是表达式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;jsx&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul>
<li><p>函数式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Comp(props) &#123;</span><br><span class="line">  return(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Comp name=&apos;&apos; style=&#123;&#123;...&#125;&#125;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Comp &#123;</span><br><span class="line">  state = &#123;&#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      prop: val, // 批量异步的，不会立刻生效</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;state =&gt; (prop: val)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;this.state.isLOgin ? &lt;p&gt;&#123;userInfo.name&#125;&lt;/p&gt; : &apos;登陆&apos;&#125;</span><br><span class="line">&#123;this.state.message &amp;&amp; &lt;p&gt;&#123;this.state.message&#125;&lt;/p&gt;&#125;</span><br><span class="line">&#123;this.state.list.map(u =&gt; &lt;li&gt;&#123;u.name&#125;&lt;/li&gt;)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.handleChange = this.handleChange.bind(this);</span><br><span class="line">&#125; // 第二种</span><br><span class="line">handleChange = () =&gt; &#123;&#125; // 第一种</span><br><span class="line">&lt;input onChange=&#123;this.handleChange&#125; /&gt; // this指向</span><br><span class="line">&lt;input onChange=&#123;() =&gt; this.handleChange(user)&#125; /&gt; // 第三种</span><br></pre></td></tr></table></figure>
<h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 属性方式通信（父组件复杂，子组件负责调用）</span><br><span class="line">// 父子组件隔代，上下文关系，及redux</span><br><span class="line">&lt;Comp titile=&#123;&#125; onSubmit=&#123;this.onSubmit&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="React-VScode开发快捷键"><a href="#React-VScode开发快捷键" class="headerlink" title="React VScode开发快捷键"></a>React VScode开发快捷键</h4><ul>
<li>按照扩展插件 <strong> ES7 React/Redux/GraphQL/React-Native snippets </strong></li>
<li>几个常用命令</li>
<li>rcc 快速穿件一个组件（使用extends方式）</li>
<li>rconst 快速创建一个 constuctor</li>
<li>rcep 快速创建一个组件（使用extends方式）</li>
<li>rcredux 快速创建一个 redux格式的类模板</li>
<li>clg 是 console.log()的快捷键<br><a href="https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets" target="_blank" rel="noopener">To Learn More…</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/14/小程序中手机号识别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/14/小程序中手机号识别/" itemprop="url">小程序中手机号识别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-14T16:38:48+08:00">
                2020-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/小程序/" itemprop="url" rel="index">
                    <span itemprop="name">小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="小程序中手机号识别"><a href="#小程序中手机号识别" class="headerlink" title="小程序中手机号识别"></a>小程序中手机号识别</h3><h4 id="后端返回字符串包好手机号，点击可拨打电话"><a href="#后端返回字符串包好手机号，点击可拨打电话" class="headerlink" title="后端返回字符串包好手机号，点击可拨打电话"></a>后端返回字符串包好手机号，点击可拨打电话</h4><ul>
<li>split技巧</li>
<li>注意的点是这个正则regPhone，里面加了有括号，如果separator是包含捕获括号的正则表达式()，则匹配结果包含在数组中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let _str = &quot;xxx，联系电话：18839687266。稍后与您联系。xxx。&quot;;</span><br><span class="line">parseStr (str) &#123;</span><br><span class="line">  const regPhone = /(1\d&#123;10&#125;)/;</span><br><span class="line">  const list = str.split(regPhone);</span><br><span class="line">  const result = [];</span><br><span class="line">  return list.map(item =&gt; &#123;</span><br><span class="line">    let tag;</span><br><span class="line">    regPhone.test(item) ? tag = &apos;phone&apos; : tag = &apos;text&apos;;</span><br><span class="line">    return &#123;</span><br><span class="line">      type: tag,</span><br><span class="line">      text: item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/03/google扩展程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/03/google扩展程序/" itemprop="url">google扩展程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-03T11:41:43+08:00">
                2020-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index">
                    <span itemprop="name">tool</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="google扩展程序安装"><a href="#google扩展程序安装" class="headerlink" title="google扩展程序安装"></a>google扩展程序安装</h4><h5 id="vue-devtools工具的安装"><a href="#vue-devtools工具的安装" class="headerlink" title="vue-devtools工具的安装"></a>vue-devtools工具的安装</h5><ul>
<li>创建一个新的文件夹，名为vue-devtools</li>
<li>sudo npm install vue-devtools</li>
<li>进入vender文件夹，打开manifest.json,进行编辑</li>
<li>persistent修改成true</li>
<li>打开扩展程序,把刚刚修改的vender文件夹拖拽进来就可以了(记得开启开发者模式)</li>
</ul>
<h5 id="react-devtools工具的安装"><a href="#react-devtools工具的安装" class="headerlink" title="react-devtools工具的安装"></a>react-devtools工具的安装</h5><ul>
<li>git clone <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">https://github.com/facebook/react-devtools</a></li>
<li>cd react-devtools</li>
<li>yarn install</li>
<li>yarn build:extension(具体命令，在package.json文件中的script下查找以下命令)</li>
<li>打开扩展程序,把生成的shells/chrome/build/unpacked文件夹拖拽进来就可以了(记得开启开发者模式)</li>
</ul>
<h5 id="redux-devtools工具的安装"><a href="#redux-devtools工具的安装" class="headerlink" title="redux-devtools工具的安装"></a>redux-devtools工具的安装</h5><ul>
<li>git clone <a href="https://github.com/zalmoxisus/redux-devtools-extension.git" target="_blank" rel="noopener">https://github.com/zalmoxisus/redux-devtools-extension.git</a></li>
<li>npm i &amp;&amp; npm run build:extension (npm install chromedriver –chromedriver_cdnurl=<a href="http://cdn.npm.taobao.org/dist/chromedriver" target="_blank" rel="noopener">http://cdn.npm.taobao.org/dist/chromedriver</a>)</li>
<li>打开扩展程序,把生成的./build/extension文件夹添加到压缩程序(记得开启开发者模式)</li>
</ul>
<h5 id="其他好用扩展程序"><a href="#其他好用扩展程序" class="headerlink" title="其他好用扩展程序"></a>其他好用扩展程序</h5><ul>
<li>WEB前端助手(FeHelper)<ul>
<li>一款国产的、超级实用的前端开发工具合集，之前扩展迷也用专文介绍过这款插件。</li>
<li>WEB前端助手(FeHelper)包含多个独立小应用，比如：Json工具、代码美化、代码压缩、二维码、Postman、markdown、网页油猴、便签笔记、信息加密与解密、随机密码生成、Crontab等等。</li>
<li><a href="https://www.extfans.com/web-development/pkgccpejnmalmdinmhkkfafefagiiiad/" style="color: blue;" target="_blank" rel="noopener">down…</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/02/nrm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/02/nrm/" itemprop="url">nrm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-02T15:23:30+08:00">
                2020-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index">
                    <span itemprop="name">tool</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li>npm install -g nrm<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5></li>
<li>nrm ls<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5></li>
<li>nrm use ‘切换的镜像’</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/17/面试指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/17/面试指南/" itemprop="url">面试指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-17T10:00:25+08:00">
                2020-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML、CSS、JS/" itemprop="url" rel="index">
                    <span itemprop="name">HTML、CSS、JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><h5 id="html5语义化"><a href="#html5语义化" class="headerlink" title="html5语义化"></a>html5语义化</h5><ul>
<li>为什么需要语义化<ul>
<li>易修改、易维护</li>
<li>无障碍阅读支持</li>
<li>搜索引擎友好，利于 SEO</li>
<li>面向未来的 HTML，浏览器在未来可能提供更丰富的支持</li>
</ul>
</li>
<li>结构语义化<ul>
<li>语义元素均有一个共同特点——他们<strong>均不做任何事情</strong>。换句话说，语义元素仅仅是<strong>页面结构的规范化</strong>，并不会对内容有本质的影响</li>
<li>eg: <header> <nav> <aside> <section> <article><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><h5 id="css常见面试题"><a href="#css常见面试题" class="headerlink" title="css常见面试题"></a>css常见面试题</h5></article></section></aside></nav></header></li>
</ul>
</li>
<li>标准盒模型与低版本IE盒模型<ul>
<li>标准盒模型 宽度 = 内容的宽度（content）+ border+ padding + margin</li>
<li>低版本IE盒模型 宽度 = 内容的宽度（content+ border+ padding）+ margin</li>
</ul>
</li>
<li>box-sizing属性<ul>
<li>用来控制元素的盒子模型的解析模式，默认为content-box</li>
<li>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽</li>
<li>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽</li>
</ul>
</li>
<li>CSS选择器有哪些？哪些属性可以继承？<ul>
<li>CSS选择符：id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child）</li>
<li>可继承的属性：font-size, font-family, color</li>
<li>不可继承的样式：border, padding, margin, width, height</li>
<li>优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]</li>
<li>!important 比内联优先级高</li>
</ul>
</li>
<li><p>CSS优先级算法如何计算？</p>
<ul>
<li>元素选择符： 1</li>
<li>class选择符： 10</li>
<li>id选择符：100</li>
<li>元素标签：1000</li>
<li>!important声明的样式优先级最高，如果冲突再进行计算</li>
<li>如果优先级相同，则选择最后出现的样式</li>
<li>继承得到的样式的优先级最低</li>
</ul>
</li>
<li><p>CSS3新增伪类有那些?</p>
<ul>
<li>p:first-of-type 选择属于其父元素的首个元素</li>
<li>p:last-of-type 选择属于其父元素的最后元素</li>
<li>p:only-of-type 选择属于其父元素唯一的元素</li>
<li>p:only-child 选择属于其父元素的唯一子元素</li>
<li>p:nth-child(2) 选择属于其父元素的第二个子元素</li>
<li>:enabled :disabled 表单控件的禁用状态</li>
<li>:checked 单选框或复选框被选中</li>
</ul>
</li>
<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？（更优方法flexbox）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">margin: 0 auto; </span><br><span class="line">height: 50px;</span><br><span class="line">width: 80px;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br><span class="line">float: left;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: -50px 0 0 -100px;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid black;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>display有哪些值？说明他们的作用?</p>
<ul>
<li>inline（默认）–内联</li>
<li>none–隐藏</li>
<li>block–块显示</li>
<li>table–表格显示</li>
<li>list-item–项目列表</li>
<li>inline-block</li>
<li>flex grid</li>
</ul>
</li>
<li><p>position的值？</p>
<ul>
<li>static（默认）：按照正常文档流进行排列；</li>
<li>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；</li>
<li>absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；</li>
<li>fixed(固定定位)：所固定的参照对像是可视窗口。<br><a href="https://segmentfault.com/a/1190000013325778" style="color: blue;" target="_blank" rel="noopener">more…</a></li>
</ul>
</li>
</ul>
<h4 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h4><h5 id="js常见面试题"><a href="#js常见面试题" class="headerlink" title="js常见面试题"></a>js常见面试题</h5><ul>
<li><p>浅拷贝和深拷贝的区别</p>
<ul>
<li><p>浅拷贝：一般指的是把对象的第一层拷贝到一个新对象上去，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123; count: 1, deep: &#123; count: 2 &#125; &#125;;</span><br><span class="line">let b = Object.assign(&#123;&#125;, a);</span><br><span class="line">// 或者</span><br><span class="line">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝：一般需要借助递归实现，如果对象的值还是个对象，要进一步的深入拷贝，完全替换掉每一个复杂类型的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let deepCopy = (obj) =&gt; &#123;</span><br><span class="line">  let ret = &#123;&#125;;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    let value = obj[key];</span><br><span class="line">    ret[key] = typeof value === &apos;object&apos; ? deepCopy(value) : value;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/21/每日面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yongfeng.peng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/blog-avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shero.">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/21/每日面试题/" itemprop="url">每日面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-21T16:33:41+08:00">
                2020-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="每日面试题"><a href="#每日面试题" class="headerlink" title="每日面试题"></a>每日面试题</h4><h5 id="输出以下代码运行结果，为什么？如果希望每隔-1s-输出一个结果，应该如何改造？注意不可改动-square-方法"><a href="#输出以下代码运行结果，为什么？如果希望每隔-1s-输出一个结果，应该如何改造？注意不可改动-square-方法" class="headerlink" title="输出以下代码运行结果，为什么？如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法"></a>输出以下代码运行结果，为什么？如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const list = [1, 2, 3]</span><br><span class="line">const square = num =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(num * num)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  list.forEach(async x =&gt; &#123;</span><br><span class="line">    const res = await square(x)</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<ul>
<li>forEach是不能阻塞的，默认是请求并行发起，所以是同时输出1、4、9</li>
<li>解决方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  for (let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    let x = list[i]</span><br><span class="line">    const res = await square(x)</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">  for (let x of list) &#123;</span><br><span class="line">    const res = await square(x)</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">## axios 源码里所用到的，利用 promise 本身的链式调用来实现串行</span><br><span class="line">let promise = Promise.resolve()</span><br><span class="line">function test(i = 0) &#123;</span><br><span class="line">  if (i === list.length) return</span><br><span class="line">  promise = promise.then(() =&gt; square(list[i])).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  test(i + 1)</span><br><span class="line">&#125;</span><br><span class="line">## 利用promise的链式调用</span><br><span class="line">function test() &#123;</span><br><span class="line">  let promise = Promise.resolve()</span><br><span class="line"></span><br><span class="line">  list.forEach(x =&gt; &#123;</span><br><span class="line">    promise = promise.then(() =&gt; square(x)).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="标记的模板字符串"><a href="#标记的模板字符串" class="headerlink" title="标记的模板字符串"></a>标记的模板字符串</h5><ul>
<li>第一个参数包含所有的静态字符串，以表达式变量进行分割成数组（类似split(‘$’)的效果）；然后逐一解析变量表达式，传到对应的参数第二个参数、第三个参数</li>
<li>拓展：<strong>参数传递的对象</strong>和我们用于<strong>检查相等性的对象</strong>在内存中位于不同位置，所以它们的引用是不同的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getPersonInfo(one, two, three) &#123;</span><br><span class="line">  console.log(one);</span><br><span class="line">  console.log(two);</span><br><span class="line">  console.log(three);</span><br><span class="line">&#125;</span><br><span class="line">const person = &quot;Lydia&quot;;</span><br><span class="line">const age = 21;</span><br><span class="line">getPersonInfo`$&#123;person&#125; is $&#123;age&#125; years old`; </span><br><span class="line">* [&quot;&quot;, &quot;is&quot;, &quot;years old&quot;] Lydia 21</span><br><span class="line">* 第一个参数&apos;$&#123;person&#125; is $&#123;age&#125; years old&apos;.split(&apos;$&apos;) =》 [&quot;&quot;, &quot;&#123;person&#125; is &quot;, &quot;&#123;age&#125; years old&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h5><ul>
<li>eval会为字符串传递的代码求值。 如果它是一个表达式，它会计算表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sum = eval(&quot;10*10+5&quot;); // 105</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="对象键"><a href="#对象键" class="headerlink" title="对象键"></a>对象键</h5><ul>
<li>所有对象键（不包括<strong>Symbols</strong>）都会被存储为字符串，即使你没有给定字符串类型的键</li>
<li>拓展<ul>
<li>如果对象有两个具有相同名称的键，则将替换前面的键。它仍将处于最开始的位置，但具有最后指定的值。</li>
<li>JavaScript全局执行上下文为你创建了两个东西:全局对象和this关键字.</li>
<li>基本执行上下文是全局执行上下文:它是代码中随处可访问的内容。</li>
<li>对象键自动转换为字符串,它变成了[object Object]</li>
<li>JavaScript只有<strong>原始类型和对象</strong>,原始类型是boolean，null，undefined，bigint，number，string和symbol。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot; &#125;;</span><br><span class="line">const set = new Set([1, 2, 3, 4, 5]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&quot;1&quot;); // true</span><br><span class="line">obj.hasOwnProperty(1); // true</span><br><span class="line">set.has(&quot;1&quot;); // false</span><br><span class="line">set.has(1); // true</span><br><span class="line"></span><br><span class="line">const obj = &#123; a: &quot;one&quot;, b: &quot;two&quot;, a: &quot;three&quot; &#125;;</span><br><span class="line">console.log(obj); // &#123; a: &quot;three&quot;, b: &quot;two&quot; &#125;</span><br><span class="line"></span><br><span class="line">const a = &#123;&#125;;</span><br><span class="line">const b = &#123; key: &quot;b&quot; &#125;;</span><br><span class="line">const c = &#123; key: &quot;c&quot; &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = 123;</span><br><span class="line">a[c] = 456;</span><br><span class="line"></span><br><span class="line">console.log(a[b]); // 456</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="continue-声明终止当前循环或标记循环的当前迭代中的语句执行，并在下一次迭代时继续执行循环"><a href="#continue-声明终止当前循环或标记循环的当前迭代中的语句执行，并在下一次迭代时继续执行循环" class="headerlink" title="continue 声明终止当前循环或标记循环的当前迭代中的语句执行，并在下一次迭代时继续执行循环"></a>continue 声明终止当前循环或标记循环的当前迭代中的语句执行，并在下一次迭代时继续执行循环</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let text = &apos;&apos;;</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  if (i === 3) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">console.log(text);</span><br><span class="line">// expected output: &quot;012456789&quot;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/blog-avatar.jpeg" alt="yongfeng.peng">
            
              <p class="site-author-name" itemprop="name">yongfeng.peng</p>
              <p class="site-description motion-element" itemprop="description">(女英</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yongfeng.peng</span>

  
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
</html>
